### Kotlin Vocabulary: Suspend Functions

#### Context
Coroutines are a future of kotlin that simplify asynchronous operations on Android. A new `suspend` modifier was introduced in the language, it is used for functions that need to be run inside the coroutine. In this video, I will tell you more about why coroutines are important and how they work under the hood. This will help you better understand why a suspend function won't return until all the work that it has started has completed, and also how a coroutine can suspend without blocking threads.

#### Suspend Modifier
Use coroutines to manage asynchronous tasks that might otherwise block the main thread and cause your app to freeze. Coroutines are also helpful to replace callback-based APIs with imperative looking code. Let's see an example of asynchronous code that uses callbacks.

Here, we have the function `loginUser`. After making an echo request to get user information from the internet, it saves the result to the local database and returns the result of that call -- all of them using callbacks. The result of the computation is returns using the `userResult` callback that is passed in as a parameter of the function. Code that heavily uses callbacks can become hard to read and understand. Kotlin coroutines let you convert callback-based code to sequential code. Code read in sequentially is typically easier to read, and unlike callbacks, coroutines provide an easy way to swap between threads and handle exceptions. 

```kotlin
fun loginUser(userId: String, password: String, userResult: Callback<User>) {

	// Async callbacks
	userRemoteDataSource.loginUser(userId, password) { user ->
		// Successful network request
		userLocalDataSource.logUserIn(user) { userDb ->
			// Result saved in DB
			userResult.success(userDb)
		}
	}
}

```

See the same function return with coroutines. We added the suspend modifier to the function, and now it returns user instead of having that callback we used to pass in as a parameter. As you can see from the wiggly icon in the code there, the other functions called from the suspend function body are also suspend functions. That suspend modifier tells the compiler that this function needs to be executed inside a coroutine. As a developer, you can think of a suspend function as a regular function whose execution might be suspended and resumed at some point. If you're new to coroutines in Android and want to learn more about them, I would recommend going through the coroutines Codelabs first. 

```kotlin
suspend fun loginUser(userId: String, password: String): User{
	val user = userRemoteDataSource.loginUser(userId, password)
	val userDb = userLocalDataSource.logUserIn(user)
	return userDb
}

```

But what's the compiler actually doing under the hood when we mark the function as suspend? 


#### Under the hood
Under the hood, the Kotlin compiler takes suspend functions and converts them to an optimized version of callbacks using a finite state machine. The Kotlin compiler will write those callbacks for you. The way suspend functions communicate with each other is with continuation objects. A `Continuation` is just a generic callback interface with some extra information. `context` will be the CoroutineContext to be used in that continuation. `resumeWith` resumes execution of the coroutine with a result that can contain either a value, which is the result of the computation that caused the suspension or an exception. With Kotlin 1.3, you also have convenient extension functions called `resume` and `resumeWithException` that are specialized versions of the `resumeWith` function.

```kotlin
// kotlin.coroutines.Continuation.kt
interface Continuation<in T> {
	public val context: CoroutineContext
	public fun resumeWith(value: Result<T>)
}

@SinceKotlin("1.3")
fun <T> Continuation<T>.resume(value: T)

@SinceKotlin("1.3")
fun <T> Continuation<T>.resumeWithException(exception: Throwable)

```

Back to our suspend function, how is the compiler going to modify it? It will replace the `suspend` modifier with an extra parameter called completion, of type Continuation in the function signature. That will be used to communicate the result of the suspend function computation to the coroutine that called it, as you can see in the code. Also, the return type of the transformed function is `Unit` instead of `User`. The user object will be returned in the added Continuation parameter. As a disclaimer, the code we are showing will not fully match the bytecode generated by the compiler. It would be Kotlin code accurate enough to allow you to understand what's really happening internally.

Back to the code again. The Kotlin compiler will identify when the function can suspend internally. Every suspension point will be represented as a state in the finite state machine. And these states are represented with labels by the compiler. For better presentation, the compiler will use a when statement to implement the different states. 

```kotlin
// organized code in kotlin and based on coroutines version 1.3
fun loginUser(userId: String, password: String, completion: Continuation<Any?>){
	
	// Label 0 -> first execution
	val user = userRemoteDataSource.loginUser(userId, password)

	// Label 1 -> resumes from userRemoteDataSource
	val userDb = userLocalDataSource.logUserIn(user)

	// Label 2 -> resumes from userLocalDataSource
	completion.resume(userDb)
}

==>
fun loginUser(userId: String, password: String, completion: Continuation<Any?>){
	
	when (label) {
		0 -> {
			// Label 0 -> first execution
			val user = userRemoteDataSource.loginUser(userId, password)
		}

		1 -> {
			// Label 1 -> resumes from userRemoteDataSource
			val userDb = userLocalDataSource.logUserIn(user)
		}

		2 -> {
			// Label 2 -> resumes from userLocalDataSource
			completion.resume(userDb)
		}

		else -> throw IllegalStateException(...)
	}
}

```



